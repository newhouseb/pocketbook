<html>
<head>
<meta charset='utf-8'>
<title>Pocketbook</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>
<style>
.medium-style .content {
  margin-left: auto;
  margin-right: auto;
  width: 700px;
}

.medium-style h1 {
  font-family: helvetica, arial;
  font-size: 42px;
  margin-top: 5px;
  margin-bottom: 5px;
}

.medium-style h2, h3, h4, strong {
  font-family: helvetica, arial;
  margin-top: 0px;
  margin-bottom: 0px;
}

.medium-style p {
  font-size: 18px;
  color: #444;
  text-align: justify;
}

.medium-style li {
  font-size: 18px;
  color: #444;
}

.medium-style a {
  color: black;
}

.medium-style .block {
  padding: 10px;
  padding-top: 2px;
  padding-bottom: 2px;
  margin: 0px;
  border-right: 2px solid white;
  min-height: 10px;
}

.medium-style .focused {
  border-right: 2px solid black;
}

.medium-style pre {
  background-color: #f3f3f3;
  padding: 5px;
  margin-bottom: 0px;
  margin-top: 0px;
}

.medium-style hr {
  margin: 40px;
  border: 0;
  border-bottom: 1px solid #ccc;
}

.medium-style .result {
  border: 1px solid #f3f3f3;
  border-top: 0px;
  padding: 5px;
}

.hide-source .result {
  border: 0px;
}

.hide-source .source {
  display: none;
}

.hide-result .result {
  display: none;
}

.content {
  position: relative;
  padding-top: 10px;
}

#controls {
  position: absolute;
  right: -170px;
  top: 0px;
  width: 140px;
  padding: 0px;
  background: #333;
  border-radius: 3px;
}

#controls button, label {
  display: block;
  width: 100%;
  text-align: left;
  background: transparent;
  color: #ccc;
  border-bottom: 1px solid #444;
  font-size: 16px;
  font-family: system-ui;
  padding: 10px;
  margin: 0px;
  box-sizing: border-box;
  cursor: pointer;
}

.control {
  position: relative;
}

#controls button:hover, label:hover {
  color: white;
  background: #444;
}

body {
  margin: 0px;
  padding: 0px;
}

.control input {
  text-align: right; 
  position: float;
  float: right;
}

#topbar {
  //border-bottom: 1px solid #dedede;
  padding: 10px;
  height: 40px;
  line-height: 40px;
}

@keyframes redfade {
    from {background-color: red;}
    to {background-color: transparent;}
}

.blink {
  animation-name: redfade;
  animation-duration: 0.5s;
}

button {
  padding: 5px;
  font-size: 16px;
  border: 0px;
  background-color: white;
  cursor: pointer;
}

button:hover {
  color: blue;
}

#topbar button {
  float: right;
  border-radius: 5px;
  padding: 10px;
  background-color: #333;
  color: #ccc;
  margin-left: 10px;
}

#topbar button:hover {
  background-color: #444;
  color: #fff;
}

select {
  border: 0;
  font-size: 16px;
  background-color: #282828;
  -webkit-appearance: none;
  color: #ccc;
  width: 100%;
  border-bottom: 1px solid #444;
  padding: 10px;
  margin: 0px;
  cursor: pointer;
}

select:hover {
  background: #444;
  color: white;
}

input[type="checkbox"] {
    opacity: 0;
}

label::after {
    position: absolute;
    top: 11px;
    right: 10px;
    content: "";
    width: 14px;
    height: 14px;
    display: inline-block;
    border: 1px solid #555;   
    border-radius: 3px;
}

input[type="checkbox"]:checked + label::after  {
    background-color: #555;
}


.divot {
  position: absolute;
  top: 12px;
  right: 10px;
  color: #555;
}

#credits {
  width: 300px;
  margin-top: 100px;
  margin-left: auto;
  margin-right: auto;
  color: #ccc;
  text-align: center;
}

#status {
  font-family: system-ui;
  float: left;
  margin-left: 10px;
  color: #ccc;
}

#status a {
  color: #ccc;
}

#hamburger {
  float: left;
}

#hamburger div {
    width: 35px;
    height: 5px;
    background-color: #ccc;
    margin: 6px 0;
}

#topmenu {
  width: 200px;
  background-color: #333;
  display: none;
  position: fixed;
  top: 48px;
  left: 10px;
}

#hamburger:hover ~ #topmenu {
  display: block;
}

#topmenu:hover {
  display: block;
}

#topmenu button {
  display: block;
  width: 100%;
  text-align: left;
  color: #ccc;
  border-bottom: 1px solid #444;
  font-size: 16px;
  font-family: system-ui;
  padding: 10px;
  margin: 0px;
  box-sizing: border-box;
  cursor: pointer;
  border-radius: 0px;
}

</style>
</head>
<body class="medium-style">
<div id="topbar">
  <div id="hamburger">
    <div></div>
    <div></div>
    <div></div>
  </div>
  <div id="status">Up to Date</div>
  <div id="topmenu"></div>
</div>
<div id="controls"></div>
<div class="content">
        <div class="metadata" style="display: none;"></div>
        <div data-lang="md" data-visibility="output" data-autorun="false" class="block hide-source" data-source-visibility="hidden">
          <pre class="source hljs coffeescript" contenteditable="true"><span class="hljs-comment"># PocketBook</span>
      <span class="hljs-comment">##A Lightweight Programming Notebook</span>
      
      Over the past number <span class="hljs-keyword">of</span> years [I](http:<span class="hljs-regexp">//</span>bennewhouse.com) have become increasingly attached to programming <span class="hljs-keyword">in</span> environments like [Jupyter Notebooks](http:<span class="hljs-regexp">//</span>jupyter.org). Tools such <span class="hljs-keyword">as</span> these <span class="hljs-keyword">do</span> a great job <span class="hljs-keyword">of</span> presenting incremental thinking <span class="hljs-keyword">as</span> one works through a problem. This <span class="hljs-keyword">is</span> particularly valuable <span class="hljs-keyword">in</span> software <span class="hljs-keyword">as</span> programmers are often constrained <span class="hljs-keyword">by</span> what they can model <span class="hljs-keyword">in</span> their head. Nevertheless, these environments can often be quite heavyweight, requiring a server <span class="hljs-keyword">and</span> a bunch <span class="hljs-keyword">of</span> configuration to get a workflow that suits ones needs.
      
      In parallel to <span class="hljs-keyword">this</span>, I<span class="hljs-string">'ve spent an increasing amount of time writing code in dialects of [LISP](https://en.wikipedia.org/wiki/Lisp_(programming_language)). LISP is an acquired taste, but what I find particularly enjoyable about LISP is the idea of tools that are self-modifying (via "macros" in the case of LISP). While this self-modification can quickly devolve into dangerously unmaintainable software, it is an incredibly powerful tool when prototyping and exploring how we build the things we build.
      
      **PocketBook** lives at the intersection of these two concepts. It is a single HTML page that allows one to write and compute inline, while at the same time being incredibly flexible to self-modification: one can introduce new languages and add new functionality all without modifying the underlying code. It'</span>s also designed to be presentable so that one can use it <span class="hljs-keyword">in</span> websites <span class="hljs-keyword">or</span> <span class="hljs-keyword">as</span> a lightweight blogging platform.
      
      ---
      
      <span class="hljs-comment">## A Quick Introduction</span>
      
      PocketBook ships with a few different <span class="hljs-string">"Languages"</span> inline:
      
      - **Javascript**
      - **Markdown**
      - **Dependencies**
      
      For <span class="hljs-keyword">this</span> bit <span class="hljs-keyword">of</span> expository introductions, I<span class="hljs-string">'m using **Markdown**. You can find the source by hovering over this text and clicking *Show Source*.
      Next, let'</span>s look at some basic **Javascript.** At its most basic, you can use it like a calculator:
      
      
      </pre>
          <div class="result"><h1 id="pocketbook">PocketBook</h1>
      <h2 id="alightweightprogrammingnotebook">A Lightweight Programming Notebook</h2>
      <p>Over the past number of years <a href="http://bennewhouse.com">I</a> have become increasingly attached to programming in environments like <a href="http://jupyter.org">Jupyter Notebooks</a>. Tools such as these do a great job of presenting incremental thinking as one works through a problem. This is particularly valuable in software as programmers are often constrained by what they can model in their head. Nevertheless, these environments can often be quite heavyweight, requiring a server and a bunch of configuration to get a workflow that suits ones needs.</p>
      <p>In parallel to this, I've spent an increasing amount of time writing code in dialects of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">LISP</a>. LISP is an acquired taste, but what I find particularly enjoyable about LISP is the idea of tools that are self-modifying (via "macros" in the case of LISP). While this self-modification can quickly devolve into dangerously unmaintainable software, it is an incredibly powerful tool when prototyping and exploring how we build the things we build.</p>
      <p><strong>PocketBook</strong> lives at the intersection of these two concepts. It is a single HTML page that allows one to write and compute inline, while at the same time being incredibly flexible to self-modification: one can introduce new languages and add new functionality all without modifying the underlying code. It's also designed to be presentable so that one can use it in websites or as a lightweight blogging platform.</p>
      <hr>
      <h2 id="aquickintroduction">A Quick Introduction</h2>
      <p>PocketBook ships with a few different "Languages" inline:</p>
      <ul>
      <li><strong>Javascript</strong></li>
      <li><strong>Markdown</strong></li>
      <li><strong>Dependencies</strong></li>
      </ul>
      <p>For this bit of expository introductions, I'm using <strong>Markdown</strong>. You can find the source by hovering over this text and clicking <em>Show Source</em>.</p>
      <p>Next, let's look at some basic <strong>Javascript.</strong> At its most basic, you can use it like a calculator:</p></div>
        </div><div data-lang="js" data-visibility="source" data-autorun="false" class="block">
          <pre class="source hljs cs" contenteditable="true"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
      x*x + <span class="hljs-number">3</span>*x + <span class="hljs-number">4</span>
      </pre>
          <div class="result">14</div>
        </div><div data-lang="md" data-source-visibility="hidden" data-result-visibility="visible" data-autorun="false" class="block hide-source"><pre class="source hljs coffeescript" contenteditable="true">Whatever <span class="hljs-keyword">is</span> returned <span class="hljs-keyword">from</span> the last expression <span class="hljs-keyword">is</span> rendered <span class="hljs-keyword">in</span> the resulting output, so <span class="hljs-keyword">if</span> you <span class="hljs-keyword">return</span> a DOM Element, it will render inline:</pre><div class="result"><p>Whatever is returned from the last expression is rendered in the resulting output, so if you return a DOM Element, it will render inline:</p></div></div><div data-lang="js" data-source-visibility="visible" data-result-visibility="visible" data-autorun="false" class="block"><pre class="source hljs javascript" contenteditable="true"><span class="hljs-keyword">let</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'button'</span>);
      button.innerHTML = <span class="hljs-string">'Click Me'</span>;
      button.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ alert(<span class="hljs-string">'Hello!'</span>); };
      button
      </pre><div class="result"><button>Click Me</button></div></div><div data-lang="md" data-source-visibility="hidden" data-result-visibility="visible" data-autorun="false" class="block hide-source"><pre class="source hljs cs" contenteditable="true">Now, <span class="hljs-keyword">let</span><span class="hljs-string">'s get a little fancy and add a new language. We'</span>ll <span class="hljs-keyword">add</span> my LISP <span class="hljs-keyword">using</span> a dependency block. A dependency block includes other scripts, <span class="hljs-function">one per each <span class="hljs-title">line</span> (<span class="hljs-params"><span class="hljs-keyword">in</span> parallel, but we only have one here</span>):</span></pre><div class="result"><p>Now, let's get a little fancy and add a new language. We'll add my LISP using a dependency block. A dependency block includes other scripts, one per each line (in parallel, but we only have one here):</p></div></div><div data-lang="deps" data-source-visibility="visible" data-result-visibility="hidden" data-autorun="true" class="block hide-result"><pre class="source hljs cpp" contenteditable="true">http:<span class="hljs-comment">//bencubator.com/lib/blip-071718.js</span></pre><div class="result" style="display: none;">[object Event]</div></div><div data-lang="md" data-source-visibility="hidden" data-result-visibility="visible" data-autorun="false" class="block hide-source"><pre class="source hljs sql" contenteditable="true">Now let's <span class="hljs-keyword">use</span> the aforementioned <span class="hljs-keyword">self</span>-<span class="hljs-keyword">modification</span> <span class="hljs-keyword">to</span> wire up the <span class="hljs-string">`evaluate`</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">as</span> a separate runtime!</pre><div class="result"><p>Now let's use the aforementioned self-modification to wire up the <code>evaluate</code> function as a separate runtime!</p></div></div><div data-lang="js" data-source-visibility="visible" data-result-visibility="hidden" data-autorun="true" class="block hide-result"><pre class="source hljs php" contenteditable="true">PocketBook.Main.Languages[<span class="hljs-string">'blip'</span>] = {
        name: <span class="hljs-string">"Blip"</span>,
        <span class="hljs-keyword">eval</span>: evaluate <span class="hljs-comment">// This comes from the above script</span>
      }
      </pre><div class="result" style="display: none;">[object Object]</div></div><div data-lang="md" data-source-visibility="hidden" data-result-visibility="visible" data-autorun="false" class="block hide-source"><pre class="source hljs sql" contenteditable="true">Once this is run, we can <span class="hljs-keyword">use</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">language</span> (selected <span class="hljs-keyword">at</span> the bottom <span class="hljs-keyword">of</span> the menu <span class="hljs-keyword">on</span> the <span class="hljs-keyword">left</span> <span class="hljs-keyword">to</span> run blocks <span class="hljs-keyword">of</span> code <span class="hljs-keyword">with</span>!)</pre><div class="result"><p>Once this is run, we can use a new language (selected at the bottom of the menu on the left to run blocks of code with!)</p></div></div><div data-lang="blip" data-source-visibility="visible" data-result-visibility="visible" data-autorun="false" class="block"><pre class="source hljs bash" contenteditable="true">(<span class="hljs-built_in">let</span> (x 2)
        (+ (* x x) (+ (* 3 x) 4)))
      </pre><div class="result">14</div></div><div data-lang="md" data-source-visibility="hidden" data-result-visibility="visible" data-autorun="false" class="block hide-source"><pre class="source hljs markdown" contenteditable="true">---
      
      <span class="hljs-section"># FAQ</span>
      
      <span class="hljs-strong">**Where are things saved?**</span>
      
      By default, things are saved to local storage in your browser. If you'd like something more permanent, you can save to a Github Gist (see the menu in the top left corner). You'll need to make a personal access token to do so.
      
      <span class="hljs-strong">**Why not fork Jupyter/Iodide/ObservableHQ?**</span>
      
      A few different reasons:
      <span class="hljs-bullet">- </span>ObservableHQ isn't open source, as far as I can tell.
      <span class="hljs-bullet">- </span>I didn't to run servers (a la Jupyter): browsers are powerful these days! [<span class="hljs-string">https://pocketbook.software</span>](<span class="hljs-link">https://pocketbook.software</span>) is literally just an HTML page in an AWS S3 bucket (behind CloudFront for HTTPS).
      <span class="hljs-bullet">- </span>I wanted something tiny that made minimal assumptions about the front-end framework or transpiler de jour so that it had staying power.
      
      <span class="hljs-strong">**Can I add X feature?**</span>
      
      My first suggestion would be to try to add it inline: all of the PocketBook state is available for you to modify and the code should be pretty readable. If that doesn't work, send me a pull request! If it's good, I'll merge it.
      <div><br></div><div>If it's helpful, I wrote a little function that should dump out the latest layout of the global `PocketBook` object. `PocketBook.Main` refers to the main instance.</div></pre><div class="result"><hr>
      <h1 id="faq">FAQ</h1>
      <p><strong>Where are things saved?</strong></p>
      <p>By default, things are saved to local storage in your browser. If you'd like something more permanent, you can save to a Github Gist (see the menu in the top left corner). You'll need to make a personal access token to do so.</p>
      <p><strong>Why not fork Jupyter/Iodide/ObservableHQ?</strong></p>
      <p>A few different reasons:</p>
      <ul>
      <li>ObservableHQ isn't open source, as far as I can tell.</li>
      <li>I didn't to run servers (a la Jupyter): browsers are powerful these days! <a href="https://pocketbook.software">https://pocketbook.software</a> is literally just an HTML page in an AWS S3 bucket (behind CloudFront for HTTPS).</li>
      <li>I wanted something tiny that made minimal assumptions about the front-end framework or transpiler de jour so that it had staying power.</li>
      </ul>
      <p><strong>Can I add X feature?</strong></p>
      <p>My first suggestion would be to try to add it inline: all of the PocketBook state is available for you to modify and the code should be pretty readable. If that doesn't work, send me a pull request! If it's good, I'll merge it.</p>
      <p>If it's helpful, I wrote a little function that should dump out the latest layout of the global <code>PocketBook</code> object. <code>PocketBook.Main</code> refers to the main instance.</p></div></div><div data-lang="js" data-source-visibility="visible" data-result-visibility="visible" data-autorun="false" class="block"><pre class="source" contenteditable="true">PocketBook.Help()</pre><div class="result"><pre>Storage [Object]
          LocalStorageBackingStore [Class]
          GistBackingStore [Class]
      StorageManager [Class]
      UI [Object]
          StatelessBlockAction [Class]
          ToggleBlockAction [Class]
          BlockController [Class]
          StatelessGlobalAction [Class]
          TopBarController [Class]
      HotKeyManager [Class]
      Main [PocketBook]
          Version [Array]
          Content [HTMLDivElement]
          Languages [Object]
          BlockController [BlockController]
              Parent [PocketBook]
              Actions [Array]
              LastBlock [HTMLDivElement]
          TopBarController [TopBarController]
              Parent [PocketBook]
              Actions [Array]
          StorageManager [StorageManager]
              Parent [PocketBook]
              Source [GistBackingStore]
                  Id [String]
          HotKeyManager [HotKeyManager]
              Parent [PocketBook]
      Help [Function]
      </pre></div></div>
</div>
<div id="credits">
  Made with PocketBook.
</div>
</body>

<script>
// Don't unintentionally pollute the global Namespace
(function() {
  window.PocketBook = class PocketBook {
    constructor(content) {
      // Can be used to gate functionality 
      this.Version = [1,0,0];

      // DOM Element to present content in
      this.Content = content;

      // Keeps track of the Languages support by a given PocketBook (more can be registered inline)
      this.Languages = {
        md: {
          eval: (function() {
            var converter = new showdown.Converter();
            return function(src) { return converter.makeHtml(src); }
          })(),
          name: "Markdown"
        },
        js: {
          eval: function(src) {
            return eval(src);
          },
          name: "Javascript"
        },
        deps: {
          eval: function(src) {
            var deps = src.split('\n'); 
            var promises = [];
            for (var i = 0; i < deps.length; i++) {
              if (deps[i] == "") continue;
              promises.push(new Promise((function(dep) { return function(resolve, reject) {
                var s = document.createElement('script');
                s.src = dep;
                s.onload = resolve
                s.onerror = reject 
                document.body.append(s);
              }})(deps[i])));
            }
            return Promise.all(promises)
          },
          name: "Dependencies"
        },
      };

      this.BlockController = new PocketBook.UI.BlockController(this);
      this.TopBarController = new PocketBook.UI.TopBarController(this);
      this.TopBarController.refresh();
      // StorageManager initializes this when ready

      this.StorageManager = new PocketBook.StorageManager(this);
      this.StorageManager.initialize();

      this.HotKeyManager = new PocketBook.HotKeyManager(this);
    }
  };

  PocketBook.Storage = {};
  var LocalStorageBackingStore = PocketBook.Storage.LocalStorageBackingStore = class LocalStorageBackingStore {
    constructor(id) {
      this.Id = id;
      this.Loaded = false;
    }
    load(cb) {
      cb(window.localStorage.getItem(this.Id));
    }
    status() {
      return "Up to Date";
    }
    autosave(content) {
      window.localStorage.setItem(this.Id, content.innerHTML);
    }
    // There's no distinction between autosave and save for localstorage
    save(content) { autosave(content) }
    discardChanges() {
      window.localStorage.removeItem(this.Id);
    }
  };
  
  var GistBackingStore = PocketBook.Storage.GistBackingStore = class GistBackingStore {
    constructor(id) {
      this.Id = id
      this.Loaded = false;
      this.LastRevision = null;
      this.TemporaryStatus = null;
    }
    load(cb) {
      var pendingRevision = window.localStorage.getItem("pending-" + this.Id);
      if (pendingRevision) {
        cb(pendingRevision);
        return;
      }

      var xhttp = new XMLHttpRequest();
      xhttp.open('GET', 'https://api.github.com/gists/' + this.Id + "?seed=" + Math.random())
      xhttp.addEventListener('load', (e) => {
        if (xhttp.readyState == 4 && xhttp.status == 200) {
          var index = JSON.parse(xhttp.response)["files"]["index.html"];
          if (index["truncated"] === false) {
            this.LastRevision = index["content"];
            this.TemporaryStatus = null;
            cb(index["content"]);
          } else {
            alert("Truncated gists not yet supported");
          }
        }
      });
      xhttp.send();
      this.TemporaryStatus = "Loading existing gist";
    }
    status() {
      return (() => {
        if (this.TemporaryStatus) return this.TemporaryStatus;
        if (window.localStorage.getItem("pending-" + this.Id)) {
          return "Autosaved, pending changes";
        }
        return "Up to Date";
      })() + (this.Id ? " - <a href=\"https://gist.github.com/" + this.Id + "\">Source Gist</a>" : "");
    }
    discardChanges() {
      window.localStorage.removeItem("pending-" + this.Id);
    }
    save(content, cb) {
      if (!window.localStorage.getItem('githubkey')) {
        var key = prompt("Please enter a github api key");
        if (!key || key == "") {
          alert('Saving failed');
          return;
        }
        window.localStorage.setItem('githubkey', key);
      }
      var key = window.localStorage.getItem('githubkey')

      if (this.Id) {
        var toPatch = {
          "files": {
            "index.html": {
              "content": content.innerHTML
            }
          }
        };
        var xhttp = new XMLHttpRequest();
        xhttp.open('PATCH', 'https://api.github.com/gists/' + this.Id + '?access_token=' + key)
        xhttp.setRequestHeader('Content-Type', 'application/json');
        xhttp.addEventListener('load', (e) => {
          if (xhttp.readyState == 4 && xhttp.status == 200) {
            document.getElementById('status').innerHTML = 'Saved to Github Gist'
            window.localStorage.removeItem("pending-" + this.Id)
            this.LastRevision = content.innerHTML;
            this.TemporaryStatus = null;
            if (cb) cb(this.Id);
          }
        });
        xhttp.send(JSON.stringify(toPatch));
        this.TemporaryStatus = "Saving to existing gist";
      } else {
        var description = prompt("What should we call this gist?");
        var toPost = {
          "description": description || "A pocketbook",
          "public": true,
          "files": {
            "readme.md": {
              content: "[Click here to view this pocketbook](https://pocketbook.software/#gistredirect)"
            },
            "index.html": {
              "content": content.innerHTML
            }
          }
        };
        var xhttp = new XMLHttpRequest();
        xhttp.open('POST', 'https://api.github.com/gists?access_token=' + key)
        xhttp.setRequestHeader('Content-Type', 'application/json');
        xhttp.addEventListener('load', (e) => {
          if (xhttp.readyState == 4) {
            var response = JSON.parse(xhttp.response);
            if (response.id) {
              this.Id = response.id;
              var metadata = content.getElementsByClassName('metadata')[0];
              metadata.dataset.gist = this.Id;
              window.localStorage.removeItem("pending-" + this.Id)
              this.LastRevision = content.innerHTML;

              // This assumes implementation details about the LocalStore, so TODO: use the other store to do this;
              window.localStorage.setItem(metadata.localId || "default", content.innerHTML);

              this.TemporaryStatus = null;
              if (cb) cb(this.Id)
            }
          }
        });
        xhttp.send(JSON.stringify(toPost));
        this.TemporaryStatus = "Creating new gist";
      }
    }
    autosave(content) {
      // This is kind of wonky because focus changes the content's HTML (it adds a class)
      // TODO: denote focus via other means (nth-child selector?)
      if (this.LastRevision && content.innerHTML != this.LastRevision) {
        if (content.getElementsByClassName('focused').length > 0) {
          this.TemporaryStatus = "Waiting for break in editing to save";
          return;
        } else {
          this.TemporaryStatus = null;
        }
        console.log(content.innerHTML.length, "vs", this.LastRevision.length)
        window.localStorage.setItem("pending-" + this.Id, content.innerHTML)
        this.LastRevision = content.innerHTML;
      } else if (this.TemporaryStatus == "Waiting for break in editing to save") {
        this.TemporaryStatus = null;
      }
    }
  };

  PocketBook.StorageManager = class StorageManager {
    constructor(pocketbook) {
      this.Parent = pocketbook;
      this.Source = null;
      this._loaded = false;
    }
    // Check the redirect and the subdomains
    handleURL() {

      // If this is a redirect from a gist Readme, we need to read the referer out of the HTTPS
      // headers to figure out what gist to load
      if (window.location.hash == '#gistredirect') {
        var gistid = document.referrer.match(/gist.github.com\/[^\/]+\/([a-z0-9]+)/)[1];
        window.location = 'https://gist-' + gistid + '.pocketbook.software';
        return;
      }

      // If this is a wildcarded subdomain (for sandboxing purposes), pull the URL and stick it in
      // the metadata
      if (window.location.href.match(/gist-[a-z0-9]+\.pocketbook\.software/)) {
        var gistid = window.location.href.match(/gist-([a-z0-9]+)\.pocketbook\.software/)[1];
        var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
        metadata.gist = gistid;
      }
    }

    // Figures out whether we should be loading from a particular LocalStorage key or from a Gist
    resolveSource() {
      var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
      if (metadata.gist) {
        return new GistBackingStore(metadata.gist);
      }

      // The locally loaded bit may return another id (or a gist!) so we first load
      if (!this._loaded) {
        // This only works recursively because we know the LocalStorage Store is synchronous
        this.LoadFromStore(new LocalStorageBackingStore(metadata.localId || "default"), false)
        this._loaded = true;
        return this.resolveSource();
      }

      return new LocalStorageBackingStore(metadata.localId || "default");
    }

    // Loads everything up from the specified store into the main page's content.
    LoadFromStore(store, shouldInitialize) {
      store.load((content_) => {
        if (content_) this.Parent.Content.innerHTML = content_;
        if (shouldInitialize) {
          this.Parent.BlockController.initialize();
        }
      });
    }

    // Initialization
    initialize() {
      this.handleURL();
      this.Source = this.resolveSource();
      this.LoadFromStore(this.Source, true);
    }
  }

  PocketBook.UI = {};
  var StatelessBlockAction = PocketBook.UI.StatelessBlockAction = class StatelessBlockAction {
    constructor(name, hotkey, execute) {
      this.name = name;
      this.execute = execute;
      this.hotkey = [hotkey, execute];
    }
    render() {
      var button = document.createElement('button');
      button.innerHTML = this.name;
      button.addEventListener('click', () => {
        this.execute(document.getElementsByClassName('focused')[0]);
      });
      return button;
    }
  }
  var ToggleBlockAction = PocketBook.UI.ToggleBlockAction = class ToggleBlockAction {
    constructor(name, hotkey, checked, execute) {
      this.name = name;
      this.execute = execute;
      this.checked = checked;
      this.hotkey = [hotkey, execute];
    }
    render(block) {
      var div = document.createElement('div');
      div.className = 'control';
      var input = document.createElement('input');
      input.id = this.name;
      input.type = "checkbox";
      input.checked = this.checked(block);
      input.addEventListener('click', (e) => {
        this.execute(block, input.checked);
      });
      div.appendChild(input);
      var label = document.createElement('label');
      label.htmlFor = this.name;
      label.innerHTML = this.name;
      div.appendChild(label);
      return div;
    }
  }

  PocketBook.UI.BlockController = class BlockController {
    constructor(pocketbook) {
      this.Parent = pocketbook;

      var key = {
        CTRL: 0,
        R: 0,
      }

      this.Actions = [
        new StatelessBlockAction("Run", [key.CTRL, key.R], (block) => {
          this.runBlock(block); 
        }),
        new StatelessBlockAction("Add Above", null, function(block) {

        }),
        new StatelessBlockAction("Add Below", null, (block) => {
          var block = document.createElement("div");
          block.dataset.lang = "md";
          block.dataset.sourceVisibility = "visible";
          block.dataset.resultVisibility = "visible";
          block.dataset.autorun = "false";
          block.className = "block";

          var source = document.createElement("pre");
          source.className = "source";
          source.contentEditable = "true";

          var output = document.createElement("div");
          output.className = "result";

          block.appendChild(source);
          block.appendChild(output);
          this.initializeBlock(block);

          var focused = document.getElementsByClassName('focused')[0];
          focused.parentNode.insertBefore(block, focused.nextSibling);
        }),
        new StatelessBlockAction("Remove", null, function(block) {

        }),
        new ToggleBlockAction("Show Source", null, function(block) {
          return block.dataset.sourceVisibility != "hidden";
        }, function(block, checked) {
          block.dataset.sourceVisibility = checked ? 'visible' : 'hidden';
          if (checked) {
            block.classList.remove("hide-source");
          } else {
            block.classList.add("hide-source");
          }
        }),
        new ToggleBlockAction("Show Result", null, function(block) {
          return block.dataset.resultVisibility != "hidden";
        }, function(block, checked) {
          block.dataset.resultVisibility = checked ? 'visible' : 'hidden';
          if (checked) {
            block.classList.remove("hide-result");
          } else {
            block.classList.add("hide-result");
          }
        }),
        new ToggleBlockAction("Autorun", null, function(block) {
          return block.dataset.autorun == "true";
        }, function(block, checked) {
          block.dataset.autorun = checked ? 'true' : 'false';
        }),
        new (class {
          constructor(pocketbook) {
            this.Parent = pocketbook;
            this.name = "Choose Language";
          }
          render(block) {
            var div = document.createElement('div');
            div.style.position = 'relative';

            var divot = document.createElement('div');
            divot.className = 'divot';
            divot.innerHTML = '&#x25BC;';
            div.appendChild(divot);

            var select = document.createElement('select');
            select.addEventListener('change', function(event) {
              block.dataset.lang = event.target.value;
            });
            Object.keys(this.Parent.Languages).forEach((key) => {
              var choice = document.createElement('option');
              choice.value = key;
              choice.innerHTML = this.Parent.Languages[key].name;
              select.appendChild(choice);
            });
            select.value = block.dataset.lang;
            div.appendChild(select);

            return div;
          }
        })(this.Parent),
      ];
    }

    focusBlock(block) {
      if (document.getElementsByClassName('focused').length)
        document.getElementsByClassName('focused')[0].classList.remove('focused');
      block.classList.add('focused')
      document.getElementById('controls').style.top = block.parentNode.offsetTop + block.offsetTop + "px";
      document.getElementById('controls').style.left = block.parentNode.offsetLeft - 140 + "px";
      document.getElementById('controls').style.display = '';

      // Initialize all the actions
      var controls = document.getElementById('controls');
      controls.innerHTML = '';
      for (var i = 0; i < this.Actions.length; i++) {
        var action = this.Actions[i].render(block);
        if (action) controls.appendChild(action);
      }
    }

    blurBlock(block) {
      this.LastBlock = document.getElementsByClassName('focused')[0];
      if (this.LastBlock) this.LastBlock.classList.remove('focused')

      document.getElementById('controls').style.display = 'none';
    }

    runBlock(block, cb) {
      var console = {
        log: function (e) {
          alert(e);
        }
      };
      var handleError = function (error) {
        console.log("Got error running block", error);
        block.children[1].innerHTML = error;
      }
      try {
        Promise.resolve(this.Parent.Languages[block.dataset.lang].eval(block.children[0].innerText)).then(function (result) {
          if (result && result instanceof Element) {
            block.children[1].innerHTML = '';
            block.children[1].appendChild(result);
          } else if (result && result.render) {
            block.children[1].innerHTML = result.render();
          } 
          // This is a Janky way to detect if this is vaugely HTML like or not
          else if (typeof result == 'string' && result.indexOf('<') == -1 ) {
            block.children[1].innerHTML = '<pre>' + result + '</pre>';
          } else {
            block.children[1].innerHTML = result;
          }
          block.lastElementChild.className = (block.lastElementChild.className || "").replace(' blink', '');
          setTimeout(function () {
            block.lastElementChild.className += " blink";
            setTimeout(function () {
              block.lastElementChild.className = (block.lastElementChild.className || "").replace(' blink', '');
            }, 500);
          }, 0);
          if (cb) cb();
        }).catch(handleError);
      } catch (error) {
        handleError(error);
      }
    }

    initializeBlock(block) {
      var output = block.children[1];
      if (block.dataset.resultVisibility == 'hidden') {
        output.style.display = 'none';
      } else {
        output.style.display = '';
      }

      block.addEventListener('mouseover', (event) => { this.focusBlock(block); });
      block.addEventListener('mouseout', (event) => { this.blurBlock(block); });
    };

    initialize() {
      // Register handlers on the controls such that if you mouse off a block but onto the
      // controls we don't unfocus the source block
      this.LastBlock = null;
      document.getElementById('controls').addEventListener('mouseover', (event) => {
        this.LastBlock.classList.add('focused');
        document.getElementById('controls').style.display = '';
      });
      document.getElementById('controls').addEventListener('mouseout', (event) => {
        document.getElementById('controls').style.display = 'none';
        document.getElementsByClassName('focused')[0].classList.remove('focused');
      });

      // Slurp out any first H1 element and use it as a title
      document.title = "PocketBook: " + document.getElementsByTagName('h1')[0].innerHTML;

      // Slurp out any gist in case it exists
      var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
      if (metadata.gist) {
        //document.getElementById('source').innerHTML = '<a href="http://gist.github.com/' + metadata.gist + '">Source Gist</a>';
      }

      // Initialize every block and collect those that need to be autorun-ed
      var toAutorun = [];
      var blocks = document.getElementsByClassName("block");
      for (var i = 0; i < blocks.length; i++) {
        if (blocks[i].dataset.autorun == 'true') toAutorun.push(blocks[i]);
        this.initializeBlock(blocks[i]);
      }

      // Recursively call each autorun cell
      var doBlock = (blocks) => {
        if (blocks.length > 0) {
          this.runBlock(blocks[0], function () {
            doBlock(blocks.slice(1));
          });
        } else {

          // If nothing else left to run, kick off autosaving
          var autosave = () => {
            console.log("Autosaving")
            this.Parent.StorageManager.Source.autosave(this.Parent.Content);
            document.getElementById('status').innerHTML = this.Parent.StorageManager.Source.status();
            setTimeout(autosave, 1000);
          }
          autosave();
        }
      };
      doBlock(toAutorun);
    }
  }

  var StatelessGlobalAction = PocketBook.UI.StatelessGlobalAction = class StatelessGlobalAction {
    constructor(name, hotkey, execute) {
      this.name = name;
      this.execute = execute;
      this.hotkey = [hotkey, execute];
    }
    render() {
      var button = document.createElement('button');
      button.innerHTML = this.name;
      button.addEventListener('click', this.execute);
      return button;
    }
  }

  PocketBook.UI.TopBarController = class TopBarController {
    constructor(pocketbook) {
      this.Parent = pocketbook;
      this.Actions = [
        new StatelessGlobalAction("Save to Github Gist", null, () => {
          if (this.Parent.StorageManager.Source.constructor.name != "GistBackingStore") {
            this.Parent.StorageManager.Source = new PocketBook.Storage.GistBackingStore();
          }
          this.Parent.StorageManager.Source.save(this.Parent.Content)
        }),
        new StatelessBlockAction("Discard All Changes", null, () => {
          // Removes basically everything except the github key
          this.Parent.StorageManager.Source.discardChanges();
          window.localStorage.removeItem("default");
          location.reload();
        }),
        new StatelessGlobalAction("Download Copy", null, function() {

        })
      ];
    }
    refresh() {
      var controls = document.getElementById('topmenu');
      controls.innerHTML = '';
      for (var i = 0; i < this.Actions.length; i++) {
        var action = this.Actions[i].render();
        if (action) controls.appendChild(action);
      }
    }
  }

  PocketBook.HotKeyManager = class HotKeyManager {
    constructor(pocketbook) {
      this.Parent = pocketbook

      function downloadCopy() {
          function makeid() {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var i = 0; i < 5; i++)
              text += possible.charAt(Math.floor(Math.random() * possible.length));
            return text;
          }

          // Temporarily remove/regenerate the id and gist
          var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
          var oldgist = metadata.gist;
          if (metadata.gist != undefined) {
            delete metadata.gist;
          }
          var oldid = this.Parent.Content.id;
          this.Parent.Content.id = makeid();

          // Save things to disk
          var link = document.createElement("a");
          link.setAttribute("href", 'data:text/html,' + encodeURI(document.documentElement.outerHTML));
          link.setAttribute("download", 'pocketbook.html');
          link.click();

          // Put the IDs back
          metadata.gist = oldgist;
         this.Parent.Content.id = oldid
      }

      // Override save, since the browser default will save the unmodified HTML :(
      document.onkeydown = function(e) {
        if ((e.metaKey || e.ctrlKey) && e.keyCode === 83) {
          downloadCopy();
          e.preventDefault();
        }
      }
    }
    
  }
  
  PocketBook.Main = new PocketBook(document.getElementsByClassName('content')[0]);

  // I like to visualize software as a tree of objects, this function prints the tree of
  // an object and its public properties (based on a convention of uppercase property names
  // a la Golang) as well as their types.
  PocketBook.Help = function(obj, indent) {
    var toReturn = "";
    obj = obj || PocketBook;
    indent = indent || "";
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key]) {
        if ("ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(key[0]) != -1) {
          var type = obj[key].__proto__.constructor.name;
          if (type === 'Function') {
            if (obj[key].name) {
              type = 'Class';
            }
          }
          toReturn += indent + key + " [" + type + "]\n";
          if (key != "Parent")
            toReturn += PocketBook.Help(obj[key], indent + "    ");
        }
      }
    }
    return toReturn;
  }

})();
</script>

<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
  var blocks = document.getElementsByClassName("source");
  for (var i = 0; i < blocks.length; i++) {
    console.log("Highlighting ", i);
    blocks[i].innerHTML = blocks[i].innerText;
    hljs.highlightBlock(blocks[i]);
  }
</script>
</html>
