<html>
<head>
<meta charset='utf-8'>
<title>Pocketbook</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>
<style>
.medium-style .content {
  margin-left: auto;
  margin-right: auto;
  width: 700px;
}

.medium-style h1 {
  font-family: helvetica, arial;
  font-size: 42px;
}

.medium-style h2, h3, h4, strong {
  font-family: helvetica, arial;
}

.medium-style p {
  font-size: 18px;
}

.medium-style .block {
  padding: 10px;
  padding-top: 2px;
  padding-bottom: 2px;
  margin: 0px;
  border-right: 2px solid white;
  min-height: 10px;
}

.medium-style .focused {
  border-right: 2px solid black;
}

.medium-style pre {
  background-color: #f3f3f3;
  padding: 5px;
  margin-bottom: 0px;
  margin-top: 0px;
}

.medium-style .output {
  border: 1px solid #f3f3f3;
  border-top: 0px;
  padding: 5px;
}

.content {
  position: relative;
  padding-top: 10px;
}

#controls {
  position: absolute;
  right: -170px;
  top: 0px;
  width: 140px;
  padding: 0px;
  background: #333;
  border-radius: 3px;
}

#controls button, label {
  display: block;
  width: 100%;
  text-align: left;
  background: transparent;
  color: #ccc;
  border-bottom: 1px solid #444;
  font-size: 16px;
  font-family: system-ui;
  padding: 10px;
  margin: 0px;
  box-sizing: border-box;
  cursor: pointer;
}

.control {
  position: relative;
}

#controls button:hover, label:hover {
  color: white;
  background: #444;
}

body {
  margin: 0px;
  padding: 0px;
}

.control input {
  text-align: right; 
  position: float;
  float: right;
}

#topbar {
  border-bottom: 1px solid #dedede;
  padding: 10px;
  height: 40px;
  line-height: 40px;
}

@keyframes redfade {
    from {background-color: red;}
    to {background-color: transparent;}
}

.blink {
  animation-name: redfade;
  animation-duration: 0.5s;
}

button {
  padding: 5px;
  font-size: 16px;
  border: 0px;
  background-color: white;
  cursor: pointer;
}

button:hover {
  color: blue;
}

#topbar button {
  float: right;
  border-radius: 5px;
  padding: 10px;
  background-color: #333;
  color: #ccc;
  margin-left: 10px;
}

#topbar button:hover {
  background-color: #444;
  color: #fff;
}

select {
  border: 0;
  font-size: 16px;
  background-color: #282828;
  -webkit-appearance: none;
  color: #ccc;
  width: 100%;
  border-bottom: 1px solid #444;
  padding: 10px;
  margin: 0px;
  cursor: pointer;
}

select:hover {
  background: #444;
  color: white;
}

input[type="checkbox"] {
    opacity: 0;
}

label::after {
    position: absolute;
    top: 11px;
    right: 10px;
    content: "";
    width: 14px;
    height: 14px;
    display: inline-block;
    border: 1px solid #555;   
    border-radius: 3px;
}

input[type="checkbox"]:checked + label::after  {
    background-color: #555;
}


.divot {
  position: absolute;
  top: 12px;
  right: 10px;
  color: #555;
}

#credits {
  width: 300px;
  margin-top: 100px;
  margin-left: auto;
  margin-right: auto;
  color: #ccc;
  text-align: center;
}

#status {
  font-family: system-ui;
}

</style>
</head>
<body class="medium-style">
<div id="topbar">
  <span id="status">Up to Date</span>
  &nbsp;
  &nbsp;
  <span id="source"></span>
  &nbsp;
  &nbsp;
  <button id="saveToGithubButton" onclick="saveToGithub()">Save to Github Gist</button>
  <!-- &nbsp;
  <button id="saveToDownloadsButton" onclick="saveToDownloads()">Save to Downloads</button> -->
  &nbsp;
  <button id="revertButton" onclick="revert()">Revert to File</button>
</div>
<div id="controls">
    <button onclick="run()">Run</button>
    <button onclick="addAbove()">Add Above</button>
    <button onclick="addBelow()">Add Below</button>
    <button onclick="remove()">Remove</button>
    <div class="control"><input id="source-visibility" onclick="chooseSourceVisibility(event)" type="checkbox" /><label for="source-visibility">Show Source </label></div>
    <div class="control"><input id="result-visibility" onclick="chooseResultVisibility(event)" type="checkbox" /><label for="result-visibility">Show Result </label></div>
    <div class="control"><input id="autorun" onclick="chooseAutorun(event)" type="checkbox" /><label for="autorun">Autorun </label></div>
    <div style="position: relative;">
      <div class="divot">&#x25BC;</div>
      <select onchange="chooseLanguage(event)" id="activelang">
        <option value="md">Markdown</option>
        <option value="js">Javascript</option>
        <option value="deps">Deps</option>
      </select>
    </div>
</div>
<div id="notebook1" class="content">
  <div class="metadata" style="display: none;"></div>
  <div data-lang="md" data-visibility="output" data-autorun="false" class="block focused">
    <pre class="source" contenteditable="true">
# Hello World

Here is some exposition</pre>
    <div>
      <h1>Hello World</h1>
      <p>Here is some exposition</p>
    </div>
  </div><div data-lang="js" data-visibility="source" data-autorun="false" class="block focused">
    <pre class="source" contenteditable="true"><code>
console.log("Hello World");

bar = {
  _count: 1,
  set count(value) {
    this._count = value;
    this.render();
  },
  get count() {
    return this._count;
  },
  render: function() {
    return this.count;
  }
}</code></pre>
    <div class="output">
    Output
    </div>
  </div>
</div>
<div id="credits">
  Made with PocketBook.
</div>
</body>

<script>
// Don't unintentionally pollute the global Namespace
(function() {
  window.PocketBook = function(content) {
    this.Content = content;

    // Used for programmatically gating any functionality
    this.Version = [1,0,0];

    // Keeps track of the Languages support by a given PocketBook (more can be registered inline)
    this.Languages = {
      md: {
        eval: (function() {
          var converter = new showdown.Converter();
          return function(src) { return converter.makeHtml(src); }
        })(),
        name: "Markdown"
      },
      js: {
        eval: function(src) {
          return eval(src);
        },
        name: "Javascript"
      },
      deps: {
        eval: function(src) {
          var deps = src.split('\n'); 
          var promises = [];
          for (var i = 0; i < deps.length; i++) {
            if (deps[i] == "") continue;
            promises.push(new Promise((function(dep) { return function(resolve, reject) {
              var s = document.createElement('script');
              s.src = dep;
              s.onload = resolve
              s.onerror = reject 
              document.body.append(s);
            }})(deps[i])));
          }
          return Promise.all(promises)
        },
        name: "Dependencies"
      },
    };

    // Stores
    var LocalStorageBackingStore = this.LocalStorageBackingStore = function(id) {
      this.Id = id;
      this.Loaded = false;
      this.load = function(cb) {
        cb(window.localStorage.getItem(this.Id));
      };
      this.autosave = function() {
        window.localStorage.setItem(this.Id, content.innerHTML);
      };
      // There's no distinction between autosave and save for localstorage
      this.save = this.autosave;
    };
    var GistBackingStore = this.GistBackingStore = function(id) {
      this.Id = id;
      this.Loaded = false;
      this.load = function(cb) {
        var xhttp = new XMLHttpRequest();
        xhttp.open('GET', 'https://api.github.com/gists/' + gistid + "?seed=" + Math.random())
        xhttp.addEventListener('load', function(e) {
          if (xhttp.readyState == 4 && xhttp.status == 200) {
            var index = JSON.parse(xhttp.response)["files"]["index.html"];
            if (index["truncated"] === false) {
              cb(index["content"]);
            } else {
              alert("Truncated gists not yet supported");
            }
          }
        });
        xhttp.send();
      };
      this.save = function(content, cb) {
        if (!window.localStorage.getItem('githubkey')) {
          var key = prompt("Please enter a github api key");
          if (!key || key == "") {
            alert('Saving failed');
            return;
          }
          window.localStorage.setItem('githubkey', key);
        }
        var key = window.localStorage.getItem('githubkey')

        if (this.Id) {
          var toPatch = {
            "files": {
              "index.html": {
                "content": content
              }
            }
          };
          var xhttp = new XMLHttpRequest();
          xhttp.open('PATCH', 'https://api.github.com/gists/' + this.Id + '?access_token=' + key)
          xhttp.setRequestHeader('Content-Type', 'application/json');
          xhttp.addEventListener('load', function(e) {
            if (xhttp.readyState == 4 && xhttp.status == 200) {
              document.getElementById('status').innerHTML = 'Saved to Github Gist'
              cb(this.Id);
            }
          });
          xhttp.send(JSON.stringify(toPatch));
        } else {
          var toPost = {
            "description": "Hello World Examples",
            "public": true,
            "files": {
              "readme.md": {
                content: "[Click here to view this pocketbook](https://pocketbook.software/#gistredirect)"
              },
              "index.html": {
                "content": document.getElementsByClassName('content')[0].innerHTML
              }
            }
          };
          var xhttp = new XMLHttpRequest();
          xhttp.open('POST', 'https://api.github.com/gists?access_token=' + key)
          xhttp.setRequestHeader('Content-Type', 'application/json');
          xhttp.addEventListener('load', function(e) {
            if (xhttp.readyState == 4) {
              var response = JSON.parse(xhttp.response);
              if (response.id) {
                this.Id = response.id;
                cb(this.Id)
              }
            }
          });
          xhttp.send(JSON.stringify(toPost));
        }
      };
      this.autosave = function() {

      };
    };

    // Handles redirects and whatnot
    this.DataManager = new (function(parent) {
      this.Parent = parent
      this.Source = null;

      this._loaded = false;

      // Check the redirect and the subdomains
      this.handleURL = () => {

        // If this is a redirect from a gist Readme, we need to read the referer out of the HTTPS
        // headers to figure out what gist to load
        if (window.location.hash == '#gistredirect') {
          var gistid = document.referrer.match(/gist.github.com\/[^\/]+\/([a-z0-9]+)/)[1];
          window.location = 'https://gist-' + gistid + '.pocketbook.software';
          return;
        }

        // If this is a wildcarded subdomain (for sandboxing purposes), pull the URL and stick it in
        // the metadata
        if (window.location.href.match(/gist-[a-z0-9]+\.pocketbook\.software/)) {
          var gistid = window.location.href.match(/gist-([a-z0-9]+)\.pocketbook\.software/)[1];
          var metadata = content.getElementsByClassName('metadata')[0].dataset;
          metadata.gist = gistid;
        }
      }

      // Figures out whether we should be loading from a particular LocalStorage key or from a Gist
      this.resolveSource = () => {
        var metadata = content.getElementsByClassName('metadata')[0].dataset;
        if (metadata.gist) {
          return new GistBackingStore(metadata.gist);
        }

        // The locally loaded bit may return another id (or a gist!) so we first load
        if (!this._loaded) {
          // This only works recursively because we know the LocalStorage Store is synchronous
          this.LoadFromStore(new LocalStorageBackingStore(metadata.localId || "default"), false)
          this._loaded = true;
          return this.resolveSource();
        }

        return new LocalStorageBackingStore(metadata.localId || "default");
      }

      // Loads everything up from the specified store into the main page's content.
      this.LoadFromStore = (store, shouldInitialize) => {
        store.load((content_) => {
          if (content_) content.innerHTML = content_;
          if (shouldInitialize) {
            this.Parent.BlockController.initialize();
          }
        });
      }

      // Initialization
      this.initialize = function() {
        this.handleURL();
        this.Source = this.resolveSource();
        this.LoadFromStore(this.Source, true);
      }
    })(this);

    // Wires up all the UI for the block-level controls
    this.BlockController = new (function(parent) {
      this.Parent = parent;

      this.getFocusedBlock = function() {

      }

      var key = {
        CTRL: 0,
        R: 0,
      }

      this.StatelessBlockActionClass = function(name, hotkey, execute) {
        return new function() {
          this.name = name;
          this.render = function() {
            var button = document.createElement('button');
            button.innerHTML = name;
            button.addEventListener('click', () => {
              execute(document.getElementsByClassName('focused')[0]);
            });
            return button;
          };
          if (hotkey) this.hotkey = [hotkey, execute];
        };
      };

      this.ToggleBlockActionClass = function(name, hotkey, getState, toggle) {
        return new function() {
          this.name = name;
          this.render = function() {
            // <div class="control"><input id="autorun" onclick="chooseAutorun(event)" type="checkbox" /><label for="autorun">Autorun </label></div>
          };
          if (hotkey) this.hotkey = [hotkey, execute];
        };
      };

      this.Actions = [
        new this.StatelessBlockActionClass("Run", [key.CTRL, key.R], (block) => {
          this.runBlock(block); 
        }),
        new this.StatelessBlockActionClass("Add Above", null, function(block) {

        }),
        new this.StatelessBlockActionClass("Add Below", null, function(block) {
          var block = document.createElement("div");
          block.dataset.lang = "md";
          block.dataset.sourceVisibility = "visible";
          block.dataset.resultVisibility = "visible";
          block.dataset.autorun = "false";
          block.className = "block";

          var source = document.createElement("pre");
          source.className = "source";
          source.contentEditable = "true";

          var output = document.createElement("div");
          output.className = "output";

          block.appendChild(source);
          block.appendChild(output);
          initBlock(block);

          var focused = document.getElementsByClassName('focused')[0];
          focused.parentNode.insertBefore(block, focused.nextSibling);
        }),
        new this.StatelessBlockActionClass("Remove", null, function(block) {

        }),
        new this.ToggleBlockActionClass("Show Source", null, function(block) {
          return block.dataset.sourceVisibility != "hidden";
        }, function(block) {

        }),
        new this.ToggleBlockActionClass("Show Result", null, function(block) {
          return block.dataset.resultVisibility != "hidden";
        }, function(block) {

        }),
        new this.ToggleBlockActionClass("Autorun", null, function(block) {
          return block.dataset.autorun == "true";
        }, function(block) {

        }),
        new function() {
          this.name = "Choose Language";
          this.render = function() {

            //document.getElementById('activelang').value = block.dataset.lang;

            var lang = document.getElementById("activelang");
            var currentlang = lang.value;

            while (lang.firstChild) lang.removeChild(lang.firstChild);
            Object.keys(languages).forEach(function(key) {
              var choice = document.createElement('option');
              choice.value = key;
              choice.innerHTML = languages[key].name;
              lang.appendChild(choice);
            });
            lang.value = currentlang;
          };
        }
      ];

      this.focusBlock = function(block) {
        if (document.getElementsByClassName('focused').length)
          document.getElementsByClassName('focused')[0].className = 'block';
        block.className = 'block focused';
        document.getElementById('controls').style.top = block.parentNode.offsetTop + block.offsetTop + "px";
        document.getElementById('controls').style.left = block.parentNode.offsetLeft - 140 + "px";
        document.getElementById('controls').style.display = ''; 

        // Initialize all the actions
        var controls = document.getElementById('controls');
        controls.innerHTML = '';
        for (var i = 0; i < this.Actions.length; i++) {
          var action = this.Actions[i].render();
          if (action) controls.appendChild(action);
        }
      };

      this.blurBlock = function(block) {
        this.LastBlock = document.getElementsByClassName('focused')[0];
        this.LastBlock.className = 'block';

        document.getElementById('controls').style.display = 'none'; 
      };

      this.runBlock = (block, cb) => {
        var console = {
          log: function(e) { 
            alert(e); 
          }
        };
        var handleError = function(error) {
          console.log("Got error running block", error);
          block.children[1].innerHTML = error;
        }
        try {
          Promise.resolve(this.Parent.Languages[block.dataset.lang].eval(block.children[0].innerText)).then(function(result) {
            if (result && result.render) {
              block.children[1].innerHTML = result.render();
            } else {
              block.children[1].innerHTML = result;
            }
            block.lastElementChild.className = (block.lastElementChild.className || "").replace(' blink', '');
            setTimeout(function() {
              block.lastElementChild.className += " blink";
              setTimeout(function() {
                block.lastElementChild.className = (block.lastElementChild.className || "").replace(' blink', '');
              }, 500);
            }, 0);
            if (cb) cb();
          }).catch(handleError);
        } catch(error) {
          handleError(error);
        }
      }

      this.initializeBlock = function(block) {
        // TODO: Control visibility with CSS rather than by reading out dataset attributes
        var src = block.children[0];
        if (block.dataset.sourceVisibility == 'hidden') { 
          src.style.display = 'none';
        } else {
          src.style.display = '';
        }
        var output = block.children[1];
        if (block.dataset.resultVisibility == 'hidden') { 
          output.style.display = 'none';
        } else {
          output.style.display = '';
        }

        block.addEventListener('mouseover', (event) => { this.focusBlock(block); });
        block.addEventListener('mouseout', (event) => { this.blurBlock(block); });
      };

      this.initialize = () => {

        // Register handlers on the controls such that if you mouse off a block but onto the
        // controls we don't unfocus the source block
        this.LastBlock = null;
        document.getElementById('controls').addEventListener('mouseover', (event) => {
                this.LastBlock.className = 'block focused';
                document.getElementById('controls').style.display = ''; 
        });
        document.getElementById('controls').addEventListener('mouseout', (event) => {
                document.getElementById('controls').style.display = 'none'; 
                document.getElementsByClassName('focused')[0].className = 'block';
        });

        // Slurp out any first H1 element and use it as a title
        document.title = "PocketBook: " + document.getElementsByTagName('h1')[0].innerHTML;

        // Slurp out any gist in case it exists
        var metadata = content.getElementsByClassName('metadata')[0].dataset;
        if (metadata.gist) {
          document.getElementById('source').innerHTML = '<a href="http://gist.github.com/' + metadata.gist + '">Source Gist</a>';
        }

        // Initialize every block and collect those that need to be autorun-ed
        var toAutorun = [];
        var blocks = document.getElementsByClassName("block");
        for (var i = 0; i < blocks.length; i++) {
          if (blocks[i].dataset.autorun == 'true') toAutorun.push(blocks[i]);
          this.initializeBlock(blocks[i]);
        }

        // Recursively call each autorun cell
        var doBlock = (blocks) => {
          if (blocks.length > 0) {
            this.runBlock(blocks[0], function() {
              doBlock(blocks.slice(1));
            });
          } else {

            // If nothing else left to run, kick off autosaving
            var autosave = () => {
              console.log("Autosaving")
              this.Parent.DataManager.Source.autosave();
              setTimeout(autosave, 1000);
            }
            autosave();
          }
        };
        doBlock(toAutorun);
      }
    })(this);

    function downloadCopy() {
        function makeid() {
          var text = "";
          var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          for (var i = 0; i < 5; i++)
            text += possible.charAt(Math.floor(Math.random() * possible.length));
          return text;
        }

        // Temporarily remove/regenerate the id and gist
        var metadata = document.getElementById('metadata').dataset;
        var oldgist = metadata.gist;
        if (metadata.gist != undefined) {
          delete metadata.gist;
        }
        var content = document.getElementsByClassName('content')[0];
        var oldid = content.id;
        content.id = makeid();

        // Save things to disk
        var link = document.createElement("a");
        link.setAttribute("href", 'data:text/html,' + encodeURI(document.documentElement.outerHTML));
        link.setAttribute("download", 'pocketbook.html');
        link.click();

        // Put the IDs back
        metadata.gist = oldgist;
        content.id = oldid
    }

    // Override save, since the browser default will save the unmodified HTML :(
    document.onkeydown = function(e) {
      if ((e.metaKey || e.ctrlKey) && e.keyCode === 83) {
        downloadCopy();
        e.preventDefault();
      }
    }

    this.initialize = () => {
      this.DataManager.initialize();
      console.log("Done initializing")
    };
  };
  
  PocketBook.Main = new PocketBook(document.getElementsByClassName('content')[0]);
  PocketBook.Main.initialize();
})();
</script>

<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
  var blocks = document.getElementsByClassName("source");
  for (var i = 0; i < blocks.length; i++) {
    console.log("Highlighting ", i);
    blocks[i].innerHTML = blocks[i].innerText;
    hljs.highlightBlock(blocks[i]);
  }
</script>
</html>
