<html>
<head>
<meta charset='utf-8'>
<title>Pocketbook</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>
<style>
.medium-style .content {
  margin-left: auto;
  margin-right: auto;
  width: 700px;
}

.medium-style h1 {
  font-family: helvetica, arial;
  font-size: 42px;
}

.medium-style h2, h3, h4, strong {
  font-family: helvetica, arial;
}

.medium-style p {
  font-size: 18px;
}

.medium-style .block {
  padding: 10px;
  padding-top: 2px;
  padding-bottom: 2px;
  margin: 0px;
  border-right: 2px solid white;
  min-height: 10px;
}

.medium-style .focused {
  border-right: 2px solid black;
}

.medium-style pre {
  background-color: #f3f3f3;
  padding: 5px;
  margin-bottom: 0px;
  margin-top: 0px;
}

.medium-style .output {
  border: 1px solid #f3f3f3;
  border-top: 0px;
  padding: 5px;
}

.hide-source .source {
  display: none;
}

.content {
  position: relative;
  padding-top: 10px;
}

#controls {
  position: absolute;
  right: -170px;
  top: 0px;
  width: 140px;
  padding: 0px;
  background: #333;
  border-radius: 3px;
}

#controls button, label {
  display: block;
  width: 100%;
  text-align: left;
  background: transparent;
  color: #ccc;
  border-bottom: 1px solid #444;
  font-size: 16px;
  font-family: system-ui;
  padding: 10px;
  margin: 0px;
  box-sizing: border-box;
  cursor: pointer;
}

.control {
  position: relative;
}

#controls button:hover, label:hover {
  color: white;
  background: #444;
}

body {
  margin: 0px;
  padding: 0px;
}

.control input {
  text-align: right; 
  position: float;
  float: right;
}

#topbar {
  border-bottom: 1px solid #dedede;
  padding: 10px;
  height: 40px;
  line-height: 40px;
}

@keyframes redfade {
    from {background-color: red;}
    to {background-color: transparent;}
}

.blink {
  animation-name: redfade;
  animation-duration: 0.5s;
}

button {
  padding: 5px;
  font-size: 16px;
  border: 0px;
  background-color: white;
  cursor: pointer;
}

button:hover {
  color: blue;
}

#topbar button {
  float: right;
  border-radius: 5px;
  padding: 10px;
  background-color: #333;
  color: #ccc;
  margin-left: 10px;
}

#topbar button:hover {
  background-color: #444;
  color: #fff;
}

select {
  border: 0;
  font-size: 16px;
  background-color: #282828;
  -webkit-appearance: none;
  color: #ccc;
  width: 100%;
  border-bottom: 1px solid #444;
  padding: 10px;
  margin: 0px;
  cursor: pointer;
}

select:hover {
  background: #444;
  color: white;
}

input[type="checkbox"] {
    opacity: 0;
}

label::after {
    position: absolute;
    top: 11px;
    right: 10px;
    content: "";
    width: 14px;
    height: 14px;
    display: inline-block;
    border: 1px solid #555;   
    border-radius: 3px;
}

input[type="checkbox"]:checked + label::after  {
    background-color: #555;
}


.divot {
  position: absolute;
  top: 12px;
  right: 10px;
  color: #555;
}

#credits {
  width: 300px;
  margin-top: 100px;
  margin-left: auto;
  margin-right: auto;
  color: #ccc;
  text-align: center;
}

#status {
  font-family: system-ui;
}

</style>
</head>
<body class="medium-style">
<div id="topbar">
  <span id="status">Up to Date</span>
  &nbsp;
  &nbsp;
  <span id="source"></span>
  &nbsp;
  &nbsp;
  <button id="saveToGithubButton" onclick="saveToGithub()">Save to Github Gist</button>
  <!-- &nbsp;
  <button id="saveToDownloadsButton" onclick="saveToDownloads()">Save to Downloads</button> -->
  &nbsp;
  <button id="revertButton" onclick="revert()">Revert to File</button>
</div>
<div id="controls">
    <button onclick="run()">Run</button>
    <button onclick="addAbove()">Add Above</button>
    <button onclick="addBelow()">Add Below</button>
    <button onclick="remove()">Remove</button>
    <div class="control"><input id="source-visibility" onclick="chooseSourceVisibility(event)" type="checkbox" /><label for="source-visibility">Show Source </label></div>
    <div class="control"><input id="result-visibility" onclick="chooseResultVisibility(event)" type="checkbox" /><label for="result-visibility">Show Result </label></div>
    <div class="control"><input id="autorun" onclick="chooseAutorun(event)" type="checkbox" /><label for="autorun">Autorun </label></div>
    <div style="position: relative;">
      <div class="divot">&#x25BC;</div>
      <select onchange="chooseLanguage(event)" id="activelang">
        <option value="md">Markdown</option>
        <option value="js">Javascript</option>
        <option value="deps">Deps</option>
      </select>
    </div>
</div>
<div id="notebook1" class="content">
  <div class="metadata" style="display: none;"></div>
  <div data-lang="md" data-visibility="output" data-autorun="false" class="block focused">
    <pre class="source" contenteditable="true">
# Hello World

Here is some exposition</pre>
    <div>
      <h1>Hello World</h1>
      <p>Here is some exposition</p>
    </div>
  </div><div data-lang="js" data-visibility="source" data-autorun="false" class="block focused">
    <pre class="source" contenteditable="true"><code>
console.log("Hello World");

bar = {
  _count: 1,
  set count(value) {
    this._count = value;
    this.render();
  },
  get count() {
    return this._count;
  },
  render: function() {
    return this.count;
  }
}</code></pre>
    <div class="output">
    Output
    </div>
  </div>
</div>
<div id="credits">
  Made with PocketBook.
</div>
</body>

<script>
// Don't unintentionally pollute the global Namespace
(function() {
  window.PocketBook = class PocketBook {
    constructor(content) {
      // Can be used to gate functionality 
      this.Version = [1,0,0];

      // DOM Element to present content in
      this.Content = content;

      // Keeps track of the Languages support by a given PocketBook (more can be registered inline)
      this.Languages = {
        md: {
          eval: (function() {
            var converter = new showdown.Converter();
            return function(src) { return converter.makeHtml(src); }
          })(),
          name: "Markdown"
        },
        js: {
          eval: function(src) {
            return eval(src);
          },
          name: "Javascript"
        },
        deps: {
          eval: function(src) {
            var deps = src.split('\n'); 
            var promises = [];
            for (var i = 0; i < deps.length; i++) {
              if (deps[i] == "") continue;
              promises.push(new Promise((function(dep) { return function(resolve, reject) {
                var s = document.createElement('script');
                s.src = dep;
                s.onload = resolve
                s.onerror = reject 
                document.body.append(s);
              }})(deps[i])));
            }
            return Promise.all(promises)
          },
          name: "Dependencies"
        },
      };

      this.BlockController = new PocketBook.UI.BlockController(this);
      // StorageManager initializes this when ready

      this.StorageManager = new PocketBook.StorageManager(this);
      this.StorageManager.initialize();

      this.HotKeyManager = new PocketBook.HotKeyManager(this);
    }
  };

  PocketBook.Storage = {};
  var LocalStorageBackingStore = PocketBook.Storage.LocalStorageBackingStore = class LocalStorageBackingStore {
    constructor(id) {
      this.Id = id;
      this.Loaded = false;
    }
    load(cb) {
      cb(window.localStorage.getItem(this.Id));
    }
    autosave(content) {
      window.localStorage.setItem(this.Id, content.innerHTML);
    }
    // There's no distinction between autosave and save for localstorage
    save(content) { autosave(content) }
  };
  
  var GistBackingStore = PocketBook.Storage.GistBackingStore = class GistBackingStore {
    constructor(id) {
      this.Id = id
      this.Loaded = false;
    }
    load(cb) {
      var xhttp = new XMLHttpRequest();
      xhttp.open('GET', 'https://api.github.com/gists/' + gistid + "?seed=" + Math.random())
      xhttp.addEventListener('load', function (e) {
        if (xhttp.readyState == 4 && xhttp.status == 200) {
          var index = JSON.parse(xhttp.response)["files"]["index.html"];
          if (index["truncated"] === false) {
            cb(index["content"]);
          } else {
            alert("Truncated gists not yet supported");
          }
        }
      });
      xhttp.send();
    }
    save(content, cb) {
      if (!window.localStorage.getItem('githubkey')) {
        var key = prompt("Please enter a github api key");
        if (!key || key == "") {
          alert('Saving failed');
          return;
        }
        window.localStorage.setItem('githubkey', key);
      }
      var key = window.localStorage.getItem('githubkey')

      if (this.Id) {
        var toPatch = {
          "files": {
            "index.html": {
              "content": content
            }
          }
        };
        var xhttp = new XMLHttpRequest();
        xhttp.open('PATCH', 'https://api.github.com/gists/' + this.Id + '?access_token=' + key)
        xhttp.setRequestHeader('Content-Type', 'application/json');
        xhttp.addEventListener('load', function (e) {
          if (xhttp.readyState == 4 && xhttp.status == 200) {
            document.getElementById('status').innerHTML = 'Saved to Github Gist'
            cb(this.Id);
          }
        });
        xhttp.send(JSON.stringify(toPatch));
      } else {
        var toPost = {
          "description": "Hello World Examples",
          "public": true,
          "files": {
            "readme.md": {
              content: "[Click here to view this pocketbook](https://pocketbook.software/#gistredirect)"
            },
            "index.html": {
              "content": content.innerHTML
            }
          }
        };
        var xhttp = new XMLHttpRequest();
        xhttp.open('POST', 'https://api.github.com/gists?access_token=' + key)
        xhttp.setRequestHeader('Content-Type', 'application/json');
        xhttp.addEventListener('load', function (e) {
          if (xhttp.readyState == 4) {
            var response = JSON.parse(xhttp.response);
            if (response.id) {
              this.Id = response.id;
              cb(this.Id)
            }
          }
        });
        xhttp.send(JSON.stringify(toPost));
      }
    }
    autosave(content) {

    }
  };

  PocketBook.StorageManager = class StorageManager {
    constructor(pocketbook) {
      this.Parent = pocketbook;
      this.Source = null;
      this._loaded = false;
    }
    // Check the redirect and the subdomains
    handleURL() {

      // If this is a redirect from a gist Readme, we need to read the referer out of the HTTPS
      // headers to figure out what gist to load
      if (window.location.hash == '#gistredirect') {
        var gistid = document.referrer.match(/gist.github.com\/[^\/]+\/([a-z0-9]+)/)[1];
        window.location = 'https://gist-' + gistid + '.pocketbook.software';
        return;
      }

      // If this is a wildcarded subdomain (for sandboxing purposes), pull the URL and stick it in
      // the metadata
      if (window.location.href.match(/gist-[a-z0-9]+\.pocketbook\.software/)) {
        var gistid = window.location.href.match(/gist-([a-z0-9]+)\.pocketbook\.software/)[1];
        var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
        metadata.gist = gistid;
      }
    }

    // Figures out whether we should be loading from a particular LocalStorage key or from a Gist
    resolveSource() {
      var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
      if (metadata.gist) {
        return new GistBackingStore(metadata.gist);
      }

      // The locally loaded bit may return another id (or a gist!) so we first load
      if (!this._loaded) {
        // This only works recursively because we know the LocalStorage Store is synchronous
        this.LoadFromStore(new LocalStorageBackingStore(metadata.localId || "default"), false)
        this._loaded = true;
        return this.resolveSource();
      }

      return new LocalStorageBackingStore(metadata.localId || "default");
    }

    // Loads everything up from the specified store into the main page's content.
    LoadFromStore(store, shouldInitialize) {
      store.load((content_) => {
        if (content_) this.Parent.Content.innerHTML = content_;
        if (shouldInitialize) {
          this.Parent.BlockController.initialize();
        }
      });
    }

    // Initialization
    initialize() {
      this.handleURL();
      this.Source = this.resolveSource();
      this.LoadFromStore(this.Source, true);
    }
  }

  PocketBook.UI = {};
  var StatelessBlockAction = PocketBook.UI.StatelessBlockAction = class StatelessBlockAction {
    constructor(name, hotkey, execute) {
      this.name = name;
      this.execute = execute;
      this.hotkey = [hotkey, execute];
    }
    render() {
      var button = document.createElement('button');
      button.innerHTML = this.name;
      button.addEventListener('click', () => {
        this.execute(document.getElementsByClassName('focused')[0]);
      });
      return button;
    }
  }
  var ToggleBlockAction = PocketBook.UI.ToggleBlockAction = class ToggleBlockAction {
    constructor(name, hotkey, checked, execute) {
      this.name = name;
      this.execute = execute;
      this.checked = checked;
      this.hotkey = [hotkey, execute];
    }
    render(block) {
      var div = document.createElement('div');
      div.className = 'control';
      var input = document.createElement('input');
      input.id = this.name;
      input.type = "checkbox";
      input.checked = this.checked(block);
      input.addEventListener('click', (e) => {
        this.execute(block, input.checked);
      });
      div.appendChild(input);
      var label = document.createElement('label');
      label.htmlFor = this.name;
      label.innerHTML = this.name;
      div.appendChild(label);
      return div;
    }
  }

  PocketBook.UI.BlockController = class BlockController {
    constructor(pocketbook) {
      this.Parent = pocketbook;

      var key = {
        CTRL: 0,
        R: 0,
      }

      this.Actions = [
        new StatelessBlockAction("Run", [key.CTRL, key.R], (block) => {
          this.runBlock(block); 
        }),
        new StatelessBlockAction("Add Above", null, function(block) {

        }),
        new StatelessBlockAction("Add Below", null, (block) => {
          var block = document.createElement("div");
          block.dataset.lang = "md";
          block.dataset.sourceVisibility = "visible";
          block.dataset.resultVisibility = "visible";
          block.dataset.autorun = "false";
          block.className = "block";

          var source = document.createElement("pre");
          source.className = "source";
          source.contentEditable = "true";

          var output = document.createElement("div");
          output.className = "output";

          block.appendChild(source);
          block.appendChild(output);
          this.initializeBlock(block);

          var focused = document.getElementsByClassName('focused')[0];
          focused.parentNode.insertBefore(block, focused.nextSibling);
        }),
        new StatelessBlockAction("Remove", null, function(block) {

        }),
        new ToggleBlockAction("Show Source", null, function(block) {
          return block.dataset.sourceVisibility != "hidden";
        }, function(block, checked) {
          block.dataset.sourceVisibility = checked ? 'visible' : 'hidden';
          if (checked) {
            block.classList.remove("hide-source");
          } else {
            block.classList.add("hide-source");
          }
        }),
        new ToggleBlockAction("Show Result", null, function(block) {
          return block.dataset.resultVisibility != "hidden";
        }, function(block, checked) {
          block.dataset.resultVisibility = checked ? 'visible' : 'hidden';
          if (checked) {
            block.classList.remove("hide-result");
          } else {
            block.classList.add("hide-result");
          }
        }),
        new ToggleBlockAction("Autorun", null, function(block) {
          return block.dataset.autorun == "true";
        }, function(block, checked) {
          block.dataset.autorun = checked ? 'true' : 'false';
        }),
        new (class {
          constructor(pocketbook) {
            this.Parent = pocketbook;
            this.name = "Choose Language";
          }
          render(block) {
            var div = document.createElement('div');
            div.style.position = 'relative';

            var divot = document.createElement('div');
            divot.className = 'divot';
            divot.innerHTML = '&#x25BC;';
            div.appendChild(divot);

            var select = document.createElement('select');
            select.addEventListener('change', function(event) {
              block.dataset.lang = event.target.value;
            });
            Object.keys(this.Parent.Languages).forEach((key) => {
              var choice = document.createElement('option');
              choice.value = key;
              choice.innerHTML = this.Parent.Languages[key].name;
              select.appendChild(choice);
            });
            select.value = block.dataset.lang;
            div.appendChild(select);

            return div;
          }
        })(this.Parent),
      ];
    }

    focusBlock(block) {
      if (document.getElementsByClassName('focused').length)
        document.getElementsByClassName('focused')[0].classList.remove('focused');
      block.classList.add('focused')
      document.getElementById('controls').style.top = block.parentNode.offsetTop + block.offsetTop + "px";
      document.getElementById('controls').style.left = block.parentNode.offsetLeft - 140 + "px";
      document.getElementById('controls').style.display = '';

      // Initialize all the actions
      var controls = document.getElementById('controls');
      controls.innerHTML = '';
      for (var i = 0; i < this.Actions.length; i++) {
        var action = this.Actions[i].render(block);
        if (action) controls.appendChild(action);
      }
    }

    blurBlock(block) {
      this.LastBlock = document.getElementsByClassName('focused')[0];
      if (this.LastBlock) this.LastBlock.classList.remove('focused')

      document.getElementById('controls').style.display = 'none';
    }

    runBlock(block, cb) {
      var console = {
        log: function (e) {
          alert(e);
        }
      };
      var handleError = function (error) {
        console.log("Got error running block", error);
        block.children[1].innerHTML = error;
      }
      try {
        Promise.resolve(this.Parent.Languages[block.dataset.lang].eval(block.children[0].innerText)).then(function (result) {
          if (result && result.render) {
            block.children[1].innerHTML = result.render();
          } else {
            block.children[1].innerHTML = result;
          }
          block.lastElementChild.className = (block.lastElementChild.className || "").replace(' blink', '');
          setTimeout(function () {
            block.lastElementChild.className += " blink";
            setTimeout(function () {
              block.lastElementChild.className = (block.lastElementChild.className || "").replace(' blink', '');
            }, 500);
          }, 0);
          if (cb) cb();
        }).catch(handleError);
      } catch (error) {
        handleError(error);
      }
    }

    initializeBlock(block) {
      var output = block.children[1];
      if (block.dataset.resultVisibility == 'hidden') {
        output.style.display = 'none';
      } else {
        output.style.display = '';
      }

      block.addEventListener('mouseover', (event) => { this.focusBlock(block); });
      block.addEventListener('mouseout', (event) => { this.blurBlock(block); });
    };

    initialize() {
      // Register handlers on the controls such that if you mouse off a block but onto the
      // controls we don't unfocus the source block
      this.LastBlock = null;
      document.getElementById('controls').addEventListener('mouseover', (event) => {
        this.LastBlock.classList.add('focused');
        document.getElementById('controls').style.display = '';
      });
      document.getElementById('controls').addEventListener('mouseout', (event) => {
        document.getElementById('controls').style.display = 'none';
        document.getElementsByClassName('focused')[0].classList.remove('focused');
      });

      // Slurp out any first H1 element and use it as a title
      document.title = "PocketBook: " + document.getElementsByTagName('h1')[0].innerHTML;

      // Slurp out any gist in case it exists
      var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
      if (metadata.gist) {
        document.getElementById('source').innerHTML = '<a href="http://gist.github.com/' + metadata.gist + '">Source Gist</a>';
      }

      // Initialize every block and collect those that need to be autorun-ed
      var toAutorun = [];
      var blocks = document.getElementsByClassName("block");
      for (var i = 0; i < blocks.length; i++) {
        if (blocks[i].dataset.autorun == 'true') toAutorun.push(blocks[i]);
        this.initializeBlock(blocks[i]);
      }

      // Recursively call each autorun cell
      var doBlock = (blocks) => {
        if (blocks.length > 0) {
          this.runBlock(blocks[0], function () {
            doBlock(blocks.slice(1));
          });
        } else {

          // If nothing else left to run, kick off autosaving
          var autosave = () => {
            console.log("Autosaving")
            this.Parent.StorageManager.Source.autosave(this.Parent.Content);
            setTimeout(autosave, 1000);
          }
          autosave();
        }
      };
      doBlock(toAutorun);
    }
  }

  PocketBook.HotKeyManager = class HotKeyManager {
    constructor(pocketbook) {
      this.Parent = pocketbook

      function downloadCopy() {
          function makeid() {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var i = 0; i < 5; i++)
              text += possible.charAt(Math.floor(Math.random() * possible.length));
            return text;
          }

          // Temporarily remove/regenerate the id and gist
          var metadata = this.Parent.Content.getElementsByClassName('metadata')[0].dataset;
          var oldgist = metadata.gist;
          if (metadata.gist != undefined) {
            delete metadata.gist;
          }
          var oldid = this.Parent.Content.id;
          this.Parent.Content.id = makeid();

          // Save things to disk
          var link = document.createElement("a");
          link.setAttribute("href", 'data:text/html,' + encodeURI(document.documentElement.outerHTML));
          link.setAttribute("download", 'pocketbook.html');
          link.click();

          // Put the IDs back
          metadata.gist = oldgist;
         this.Parent.Content.id = oldid
      }

      // Override save, since the browser default will save the unmodified HTML :(
      document.onkeydown = function(e) {
        if ((e.metaKey || e.ctrlKey) && e.keyCode === 83) {
          downloadCopy();
          e.preventDefault();
        }
      }
    }
    
  }
  
  PocketBook.Main = new PocketBook(document.getElementsByClassName('content')[0]);

  // I like to visualize software as a tree of objects, this function prints the tree of
  // an object and its public properties (based on a convention of uppercase property names
  // a la Golang) as well as their types.
  PocketBook.Help = function(obj, indent) {
    var toReturn = "";
    var shouldLog = indent == undefined;
    obj = obj || PocketBook;
    indent = indent || "";
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key]) {
        if ("ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(key[0]) != -1) {
          var type = obj[key].__proto__.constructor.name;
          if (type === 'Function') {
            if (obj[key].name) {
              type = 'Class';
            }
          }
          toReturn += indent + key + " [" + type + "]\n";
          if (key != "Parent")
            toReturn += PocketBook.Help(obj[key], indent + "    ");
        }
      }
    }
    if (shouldLog) {
      console.log(toReturn);
    } else {
      return toReturn;
    }
  }

})();
</script>

<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
  var blocks = document.getElementsByClassName("source");
  for (var i = 0; i < blocks.length; i++) {
    console.log("Highlighting ", i);
    blocks[i].innerHTML = blocks[i].innerText;
    hljs.highlightBlock(blocks[i]);
  }
</script>
</html>
